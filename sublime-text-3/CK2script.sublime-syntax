%YAML 1.2
---
name: CK2script
file_extensions:
  - gfx
  - gui
scope: source.ck2script
first_line_match: -\*- ck2(\.\w[\w\.]*)? -\*-

contexts:
  main:
    - match: '#.*'
      scope: comment.line.number-sign.ck2script
    - match: '"'
      scope: punctuation.definition.string.begin.ck2script
      push:
        - meta_scope: string.quoted.double.ck2script
        - match: '"'
          scope: punctuation.definition.string.end.ck2script
          pop: true
        - match: \n
          scope: invalid.illegal.newline.ck2script
        - match: \\.
          scope: invalid.illegal.escape.ck2script
        # TODO: want to recognize localisation control sequences (e.g., '§Y') as markup of some kind, which could theoretically be colored as it is in-game
        #       --> also would like to match begin/end markup control sequences together
        #       --> also would like to match localisation command brackets together
        #           --> within these, would like to recognize the builtin localisation scopes (e.g., PrevPrev or Root or ...)
    - match: \{
      push: braces
    - match: \}
      scope: invalid.illegal.stray-bracket-end
    - match: \b(id)\s*=\s*(((\w+)\.)?(0|([1-9][0-9]*)))\b
      captures:
        1: keyword.control.ck2script
        2: entity.function.name
        # 4: some scope for namespaces or identifiers (entity.name... ?)
        5: constant.numeric
    - match: (?<!\w)(\-?([0-9]+\.)?[0-9]+)\b
      scope: constant.numeric.ck2script
    - match: \b[bcdek]_[a-z][a-z_-]+\b
      scope: variable.other.ck2script
    - match: \bc_\d+\b # character scope, not a title; integer is character ID
      scope: variable.other.ck2script
    - match: \b(clear(_global)?_event_target|save(_global)?_event_target_as)\s*=\s*([a-zA-Z]\w*)\b
      captures:
        4: variable.other.ck2script
    - match: \b(event_target:[a-zA-Z]\w*)\b
      scope: variable.other.ck2script
    - match: \b(ROOT|root|(FROM){1,4}|(from){1,4}|(PREV){1,4}|(prev){1,4}|(ROOT_(FROM){1,4})|(root_(from){1,4})|(ROOT_(from){1,4})|(root_(FROM){1,4})|THIS|this)\b
      scope: variable.language.ck2script
    - match: \b((mult_)?modifier|modifier|additive_modifier|additive_power_diff_modifier|additive_opinion_modifier)\b
      scope: keyword.control.ck2script
      # these guys are really annoying without being context-limited (and having a color scheme that gives me more than 3-4 choices):
#    - match: \b(factor|value|count|amount|days|months|years)\b
#      scope: keyword.control.ck2script
    - match: \b(hidden_tooltip|custom_tooltip|hidden_trigger|hidden_effect)\b
      scope: keyword.control.ck2script
    - match: \b(AND|OR|NOT|NOR|NAND|and|or|not|nor|nand|calc_true_if)\b
      scope: support.constant.ck2script
    - match: \b(yes|no)\b
      scope: support.constant.ck2script
    - match: \b(if|trigger_switch|limit|on_trigger)\b
      scope: keyword.control.ck2script
      # types of "events" (repeat_event is strictly a command and not also an actual event type)
    - match: \b((character|long_character|narrative|letter|diploresponse|province|unit|repeat)_event)\b
      scope: keyword.control.ck2script
      # top-level event context flags/paramters:
    - match: \b(((show_(ROOT|root))|(hide_(window|from|FROM|new))|(show(_from|_FROM){2,4})))\b
      scope: keyword.control.ck2script
    - match: \b(is_triggered_only|major|desc|is_friendly|picture|border|title|notification)\b
      scope: keyword.control.ck2script
      # top-level event effect blocks
    - match: \b(immediate|option)\b
      scope: keyword.control.ck2script
      # top-level event trigger blocks
    - match: \b(trigger|major_trigger)\b
      scope: keyword.control.ck2script
      # FUTURE DECISION/LAW CONTEXT:
    - match: \b(allow|potential|from_potential|revoke_allowed)\b # triggers
      scope: keyword.control.ck2script
    - match: \b(effect|pass_effect)\b # effects
      scope: keyword.control.ck2script
    - match: \b(ai_will_do|ai_will_revoke)\b # modifier sets
      scope: keyword.control.ck2script
      # FUTURE MINOR TITLE / RELIGIOUS TITLE CONTEXT:
    - match: \b(allowed_to_grant|allowed_to_hold|revoke_trigger)\b # triggers
      scope: keyword.control.ck2script
    - match: \b(gain_effect|lose_effect|retire_effect)\b # effects
      scope: keyword.control.ck2script
    - match: \bai_will_do\b # modifier sets
      scope: keyword.control.ck2script
      # FUTURE JOB TITLE CONTEXT:
    - match: \b(allow|dismiss_trigger)\b # triggers
      scope: keyword.control.ck2script
    - match: \b(gain_effect|lose_effect|retire_effect)\b # effects
      scope: keyword.control.ck2script
      # FUTURE CB CONTEXT:
    - match: \b((can_use(_(title|gui))?)|(is_valid(_title)?))\b
      scope: keyword.control.ck2script
    - match: \b((on_(add|success|fail|reverse_demand)(_(title|posttitle))?)|on_invalidation|on_(attacker|defender)_leader_death)\b # effects
      scope: keyword.control.ck2script
    - match: \b(((attacker|defender)_ai_(victory|defeat)_worth)|ai_will_do)\b # modifier sets
      scope: keyword.control.ck2script
      # TODO: FUTURE CONTEXT OF JOB ACTIONS, AMBITIONS, PLOTS, FOCUSES, FACTIONS, LANDED_TITLES, COUNCIL_VOTING, TRAITS,
      #       COUNCIL_POSITIONS, GOVERNMENTS, ([LONG_]CHARACTER|LETTER|NARRATIVE|PROVINCE|UNIT|DIPLORESPONSE)_EVENT, ...
      # random stuff not covered above [yet]:
    - match: \b(mean_time_to_happen|weight_multiplier|chance|membership|ai_chance)\b # modifier sets
      scope: keyword.control.ck2script
    - match: \b(random|random_list)\b # effects w/ modifier sets
      scope: keyword.control.ck2script

  braces:
    - match: \}
      pop: true
    - include: main
